<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jpeguin</title>
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Jpeguin">
  <meta property="og:description" content="Convert images to JPEG and share them easily from your mobile device.">
  <meta property="og:image" content="https://psiroki.github.io/jpeguin/jpeguin.jpeg">
  <meta property="og:image:width" content="887">
  <meta property="og:image:height" content="1295">
  <meta property="og:url" content="https://psiroki.github.io/jpeguin/">
  <meta property="og:type" content="website">
  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Jpeguin">
  <meta name="twitter:description" content="Convert images to JPEG and share them easily from your mobile device.">
  <meta name="twitter:image" content="https://psiroki.github.io/jpeguin/jpeguin.jpeg">
  <!-- Favicon -->
  <link rel="icon" type="image/jpeg" href="favicon.jpeg">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #f1f5f9;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 16px;
      color: #1f2937;
    }
    .container {
      max-width: 100%;
      width: 100%;
      max-width: 400px;
      background-color: #ffffff;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }
    .app-image {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 0 auto 24px;
      border-radius: 8px;
      max-height: 200px;
      object-fit: contain;
    }
    .slider-container, .color-container {
      margin-bottom: 24px;
    }
    label {
      display: block;
      font-size: 1.125rem;
      font-weight: 500;
      margin-bottom: 8px;
    }
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 12px;
      background: #e5e7eb;
      border-radius: 9999px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      background: #2563eb;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: #1e40af;
    }
    input[type="color"] {
      -webkit-appearance: none;
      width: 100%;
      height: 44px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 4px;
      cursor: pointer;
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
    }
    button, .file-button {
      display: block;
      width: 100%;
      padding: 16px;
      font-size: 1.125rem;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      text-align: center;
    }
    .file-button {
      background: #2563eb;
      color: #ffffff;
    }
    .file-button:hover {
      background: #1e40af;
    }
    #pasteButton {
      background: #16a34a;
      color: #ffffff;
    }
    #pasteButton:hover {
      background: #15803d;
    }
    input[type="file"] {
      display: none;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
    .drag-over::before {
      content: "Drop to convert to JPEG";
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle, rgba(37, 99, 235, 0.12) 0%, rgba(37, 99, 235, 0.04) 70%);
      box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: 600;
      color: #1e40af;
      pointer-events: none;
      user-select: none;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Jpeguin</h1>
    <img src="jpeguin.jpeg" alt="Jpeguin App Image" class="app-image">
    
    <!-- JPEG Quality Slider -->
    <div class="slider-container">
      <label for="qualitySlider">
        JPEG Quality: <span id="qualityValue">90%</span>
      </label>
      <input
        type="range"
        id="qualitySlider"
        min="0.01"
        max="1"
        step="0.01"
        value="0.9"
      >
    </div>

    <!-- Background Color Selector -->
    <div class="color-container">
      <label for="backgroundColor">Background:</label>
      <input
        type="color"
        id="backgroundColor"
        value="#ffffff"
      >
    </div>

    <!-- Load Image Button -->
    <div style="margin-bottom: 16px;">
      <label for="imageInput" class="sr-only">Load Image</label>
      <input
        type="file"
        id="imageInput"
        accept="image/*"
        style="display: none;"
      >
      <button class="file-button" onclick="document.getElementById('imageInput').click()">
        Load Image
      </button>
    </div>

    <!-- Paste Button -->
    <button id="pasteButton">Paste Image</button>
  </div>

  <script defer="defer" src="crc32.js"></script>
  <script defer="defer">
    // Load configuration from localStorage
    const defaultConfig = { quality: 0.9, backgroundColor: '#ffffff' };
    let config = JSON.parse(localStorage.getItem('jpeguin')) || defaultConfig;

    // Initialize JPEG quality slider
    const qualitySlider = document.getElementById('qualitySlider');
    const qualityValue = document.getElementById('qualityValue');
    qualitySlider.value = config.quality;
    qualityValue.textContent = `${Math.round(config.quality * 100)}%`;
    qualitySlider.addEventListener('input', () => {
      const value = parseFloat(qualitySlider.value);
      qualityValue.textContent = `${Math.round(value * 100)}%`;
      config.quality = value;
      localStorage.setItem('jpeguin', JSON.stringify(config));
    });

    // Initialize background color selector
    const backgroundColor = document.getElementById('backgroundColor');
    backgroundColor.value = config.backgroundColor;
    backgroundColor.addEventListener('input', () => {
      config.backgroundColor = backgroundColor.value;
      localStorage.setItem('jpeguin', JSON.stringify(config));
    });

    // Detect iOS/iPadOS
    function isAppleMobileDevice() {
      const userAgent = navigator.userAgent || navigator.platform || '';
      const platform = navigator.platform || '';
      const isIOS = /iPhone|iPad|iPod/.test(userAgent) || 
                    /iPhone|iPad|iPod/.test(platform) ||
                    (userAgent.includes('Macintosh') && navigator.maxTouchPoints > 2);
      return isIOS;
    }

    function generateFilename(originalName, bytes, extension) {
      let baseName = (originalName || "image").replace(/\.[^\.]+$/, "");
      const hash = crc32(bytes);
      return `${baseName}_${hash}.${extension}`;
    }

    async function downloadBlobs(imageBlobs) {
      try {
        for (const imageBlob of imageBlobs) {
          // Create download link
          const link = document.createElement("a");
          link.download = imageBlob.name || "image.jpg";
          link.href = URL.createObjectURL(imageBlob.jpegBlob);
          link.click();

          // Clean up the object URL
          URL.revokeObjectURL(link.href);
        }
      } catch (error) {
        console.error("Error downloading blobs:", error);
        throw error;
      }
    }

    // Process images (convert to JPEG and share)
    async function processImages(blobs) {
      const quality = parseFloat(qualitySlider.value);
      const imageBlobs = [];

      // Process one image at a time to avoid memory issues
      for (const blob of blobs) {
        try {
          const imageBitmap = await createImageBitmap(blob);
          
          const canvas = document.createElement('canvas');
          canvas.width = imageBitmap.width;
          canvas.height = imageBitmap.height;
          const ctx = canvas.getContext('2d');
          
          // Clear canvas with background color
          ctx.fillStyle = backgroundColor.value;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(imageBitmap, 0, 0);
          
          // Close the ImageBitmap to free memory
          imageBitmap.close();
          
          // Convert canvas to JPEG blob
          const jpegBlob = await new Promise((resolve) => {
            canvas.toBlob(resolve, 'image/jpeg', quality);
          });

          // Read blob as ArrayBuffer and convert to Uint8Array for generateFilename
          const arrayBuffer = await imageBlob.jpegBlob.arrayBuffer();
          const bytes = new Uint8Array(arrayBuffer);
          const newName = generateFilename(blob.name, bytes, "jpeg");
          
          imageBlobs.push({
            jpegBlob: jpegBlob,
            name: newName
          });
        } catch (error) {
          console.error('Error processing image:', error);
        }
      }

      if (imageBlobs.length === 0) {
        alert('No images could be processed.');
        return;
      }

      // Try to share on Apple mobile devices
      if (isAppleMobileDevice() && navigator.share && navigator.canShare) {
        const files = imageBlobs.map(imageBlob => 
          new File([imageBlob.jpegBlob], imageBlob.name || 'image.jpg', { type: 'image/jpeg' })
        );
        
        if (navigator.canShare({ files })) {
          try {
            await navigator.share({ files });
            return; // Don't download if sharing succeeded
          } catch (err) {
            console.error('Share failed (will fall back to file download):', err);
          }
        }
      }
      
      // Fall back to downloading
      await downloadBlobs(imageBlobs);
    }

    // Handle file input
    document.getElementById('imageInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file && file.type.startsWith('image/')) {
        processImage(file);
        // Reset file input to allow re-selecting the same file
        event.target.value = '';
      } else {
        alert('Please select an image file.');
      }
    });

    // Handle paste button
    document.getElementById('pasteButton').addEventListener('click', async () => {
      try {
        if (!navigator.clipboard || !navigator.clipboard.read) {
          alert('Clipboard API not supported.');
          return;
        }
        const clipboardItems = await navigator.clipboard.read();
        for (const item of clipboardItems) {
          for (const type of item.types) {
            if (type.startsWith('image/')) {
              const blob = await item.getType(type);
              processImage(blob);
              return;
            }
          }
        }
        alert('No image found in clipboard.');
      } catch (err) {
        console.error('Error accessing clipboard:', err);
        alert('Failed to access clipboard.');
      }
    });

    // Handle drag and drop events
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (dragCounter === 1) {
        document.body.classList.add('drag-over');
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        document.body.classList.remove('drag-over');
      }
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      document.body.classList.remove('drag-over');
      
      const files = Array.from(e.dataTransfer.files);
      const imageFiles = files.filter(file => file.type.startsWith('image/'));
      
      if (imageFiles.length > 0) {
        imageFiles.forEach(imageFile => processImage(imageFile));
      } else {
        alert('Please drop image files.');
      }
    });

    // Handle global paste events
    document.addEventListener('paste', async (e) => {
      const items = Array.from(e.clipboardData.items);
      const imageItem = items.find(item => item.type.startsWith('image/'));
      
      if (imageItem) {
        e.preventDefault();
        const blob = imageItem.getAsFile();
        processImage(blob);
      }
    });
  </script>
</body>
</html>